/*
 * Copyright (C) 2025 Olaf Kirch <okir@suse.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, version 2.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#ifndef FREEMAP_SCANNER_H
#define FREEMAP_SCANNER_H

#include <stdlib.h>
#include <stdbool.h>
#include <assert.h>

#include "freemap.h"
#include "lists.h"
#include "utils.h"

typedef struct fm_scan_dummy	fm_scan_state_t;

#define FM_SCAN_ACTION_FLAG_OPTIONAL	0x0001
#define FM_SCAN_ACTION_FLAG_LOCAL_ONLY	0x0100

struct fm_scan_action {
	char *			id;

	unsigned int		mode;
	unsigned int		flags;

	/* if barrier is true, wait for this and all previous scan actions
	 * to complete before progressing to the next.
	 * A scheduler that wants to implement randomized order of probes would
	 * have to carve up the list of actions into chunks, split after each
	 * barrier action.
	 */
	bool			barrier;

	/* number of probes generated by this action */
	unsigned int		nprobes;

	const struct fm_scan_action_ops {
		size_t		obj_size;

		void		(*destroy)(fm_scan_action_t *);
		bool		(*validate)(fm_scan_action_t *, fm_target_t *);
		fm_probe_t *	(*get_next_probe)(const fm_scan_action_t *, fm_target_t *, unsigned int);
	} *ops;

	/* The following bits are probe class specific. */
	fm_probe_class_t *	probe_class;
	fm_probe_params_t	probe_params;
	void *			extra_params;

	/* ports, protocol numbers, etc */
	fm_uint_array_t		numeric_params;

	/* Set when the probe class supports service probes */
	const fm_service_catalog_t *service_catalog;
};

typedef struct fm_scan_action_array {
	unsigned int		count;
	fm_scan_action_t **	entries;
} fm_scan_action_array_t;

struct fm_scanner {
	fm_target_manager_t *	target_manager;
	fm_target_pool_t *	target_pool;
	fm_report_t *		report;

	struct timeval		scan_started;
	struct timeval		next_pool_resize;

	/* We put an overall limit on the number of packets we
	 * generate per second.
	 * In addition, we put a limit on the number of packets
	 * that we send to an individual host.
	 */
	fm_ratelimit_t		send_rate_limit;

	fm_scheduler_t *	scheduler;

	const fm_service_catalog_t *service_catalog;

	unsigned int		current_stage;
	fm_scan_action_array_t	stage_requests[__FM_SCAN_STAGE_MAX];

	const fm_protocol_engine_t *proto;
};

extern fm_scan_action_t *	fm_scan_action_create(int mode, const struct fm_scan_action_ops *ops, const char *id, fm_probe_class_t *);
extern fm_scan_action_t *	fm_scanner_add_probe(fm_scanner_t *, const fm_config_probe_t *);
extern void			fm_scanner_set_service_catalog(fm_scanner_t *, const fm_service_catalog_t *);

static inline fm_scan_action_array_t *
fm_scanner_get_stage(fm_scanner_t *scanner, unsigned int stage)
{
	assert(stage < __FM_SCAN_STAGE_MAX);
	return &scanner->stage_requests[stage];
}

static inline fm_scan_action_array_t *
fm_scanner_get_current_stage(fm_scanner_t *scanner)
{
	return fm_scanner_get_stage(scanner, scanner->current_stage);
}

#endif /* FREEMAP_SCANNER_H */

